#!/usr/bin/env bash
# git-backup
#
#	@originalAuthor		Kipras Melnikovas (kipras.org) <kipras@kipras.org>
#	@license			GPL-3.0
#
#	@usage
# 1) use this script directly or
# 2) set a git alias for it:
#
# ``` ~/.gitconfig:
# [alias]
#	backup = !git-backup
# ```
#
#	@description
# 'exec' is used for 'silent' mode
#
# 'silent' mode can be useful if you only want to get
# the generated branches' name
#

usage="\
Usage:
$ git-backup [OPTION]...

Options:
    -r [remote name]
          change to which remote to push the backup branch to
          [default=origin]

    -l    local mode. Will NOT push the generated branch to remote
          [default=false]

    -q    quite mode. Will only print the backup branches' name
          [default=false]

    -h    help

Examples:
	$ git-backup
	$ git-backup -l -q
	$ git-backup -r upstream
"

printUsage() {
	printf "$usage\n"
}

# create function
git-backup() {
	# setup

	exec 6>&1 # saves stdout (see -q)

	# -q => quiet mode (return only generated branch name)
	while getopts ":hr:lq" opt; do
		case "${opt}" in
			r)
				remoteRepoName="${OPTARG}"
				;;
			l)
				shouldPushBranchToRemote="false"
				shift # forward argv by one option
				;;
			q)
				exec > /dev/null  # redirect stdout to /dev/null
				shift # forward argv by one option
				;;
			h)
				printUsage
				exit
				;;
			*)
				printUsage
				exit
				;;
		esac
	done

	printf "==> git-backup:\n"

	# make sure git repo exists
	git status >/dev/null 2>&1 || {
		# restore stdout EARLY to allow the printing of the error
		exec 1>&6 6>&-

		printf " -> error! Git repository NOT found!\n"
		return 1
	}

	# -r
	[ -z "$remoteRepoName" ] && remoteRepoName="origin"

	# -l
	[ -z "$shouldPushBranchToRemote" ] && shouldPushBranchToRemote="true"

	if [ "$shouldPushBranchToRemote" = "true" ]; then
		# make sure the remote is present

		git remote -v | grep "$remoteRepoName" >/dev/null 2>&1 && {
			shouldPushBranchToRemote="true"
			printf " -> remote ($remoteRepoName) found!\n"
		} || {
			shouldPushBranchToRemote="false"
			printf " -> remote ($remoteRepoName) NOT found!\n"
		}
	else
		printf " -> remote ignored.\n"
	fi

	## get current branch
	#currentBranch="$(git rev-parse --abbrev-ref HEAD)" && \

	# get current username (if it's set), or get the first name of `user.name`
	currentUsername="$(git config user.username || git config user.name | cut -d ' ' -f 1)" && \

	# END setup

	# BEGIN action!

	git stash --include-untracked >/dev/null 2>&1 && \

	# --format: '%f' => "sanitized subject line, suitable for a filename" (GIT-LOG(1))
	# contains '<authorDate (UNIX timestamp)>--<stashCommitId>--WIP-on-<branchName>-<stashCommitHash>-<parentCommitTitle>'
	subjectLine="$(git stash list --format='%at--%h--%f' | head -n 1)" && \

	# generate backup branch name
	backupBranchName="$currentUsername-backup--$subjectLine" && \

	# create the backup branch
	git branch "$backupBranchName" && \

	# get your changes back
	git stash pop --quiet && \

	# push to remote repo
	if [ "$shouldPushBranchToRemote" = "true" ]; then
		printf "==> Pushing to remote repo ($remoteRepoName)\n" && \
		git push "$remoteRepoName" "$backupBranchName" >/dev/null 2>&1 || {
			printf " -> Failed 'git push'.\n"
			return 1
		}
	fi && \

	printf " -> Successfully backed up current changes\n" && \
	printf " -> Backup branch (use -q to print only it): \n" && \

	# restore stdout (does NOT print it though (good))
	exec 1>&6 6>&- && \

	{
		printf "$backupBranchName\n"
		return 0
	} || {
		printf " -> Something failed!\n" && \
		return 1
	}

	# END action!
};

# call the function
git-backup "$@" && exit 0 || exit 1

